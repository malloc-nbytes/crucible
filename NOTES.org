* TODO [82%]
- [X] while loops
- [X] mut statements
- [X] convert =type_to_int(type)= to =type->sz=
- [X] for loops
- [X] break statements
- [X] continue statements
- [X] fix procedures with the same name but different namespaces (multiple definition error in linker)
- [X] imports
- [X] move build system to autotools
- [X] allow search paths and a flag '--nostd'
- [X] more mutation operators (+=, -=, etc).
- [X] casting
- [X] 'address of' operator =&var=
- [X] 'dereference operator =*var=
- [X] empty statements
- [X] null
- [X] arrays
  - [X] indexing operator =[i]=
  - [X] literals ={1, 2, 3}=
  - [X] pointer arithmetic =ar + i=
  - [X] allow for empty arrays =let ar: [i32; 5] = {};=
- [X] booleans
- [X] size_t
- [ ] macros
- [ ] global variables
- [ ] structs
  - [ ] statement =struct P {}=
  - [ ] literals =(obj) {.x = 1, .y = 2}=
  - [ ] members =p.x; p.y=
- [-] enums
  - [X] statements =enum P {}=
  - [ ] members =P.I1; P.I2=

* StdLib [66%]
- [X] strcpy
- [X] memcpy
- [X] isalpha
- [X] isdigit
- [X] isalnum
- [X] abs
- [ ] strcat # not overwriting the null bytes
- [ ] atoi (string to int) # bad asm reg and spec sizes
- [ ] memcmp # lazy

* Bugs

** Critical

The following code prints garbage.

#+begin_src
let x: u8 = 97;
cstdio::printf("%d\n", x);
#+end_src

** Misc.

The following has incorrect size specifications.

#+begin_src
export proc or2_r1(void): i32
{
        log::id("logical::or2_r1");
        return (i32)(0 || 1);
}
#+end_src

The following segfaults only if using zeroing.

#+begin_src
        let src: u8* = "hello";
        let buf: [u8; 10] = {0};

        bytes::copy((u8*)buf, src);
#+end_src

The following code prints nothing

#+begin_src
module main where

import std.binds.c.stdio;

export proc _start(void): !
{
        let buf: [u8; 7] = {'a', 'b', 'c', 'd', 'e', 'f', 0};

        cstdio::printf("%s\n", buf);

        exit;
}
#+end_src
